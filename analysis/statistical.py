"""
Statistical analysis component for drug scores.

This component performs statistical analysis on drug scores generated by drug2cell,
including t-tests, correlation analysis, and comprehensive visualizations.
"""

import warnings
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
from typing import Dict, List, Any, Tuple
import statsmodels.api as sm
from statsmodels.discrete.discrete_model import Logit, BinaryResultsWrapper
from scipy import stats
from scipy.stats import ttest_ind, mannwhitneyu
from statsmodels.stats.multitest import fdrcorrection

from core.base import BaseVisualizationAnalyzer
from config.constants import CELL_TYPE_COLORS, CELL_TYPE_MAPPING, CELL_TYPE_COLORS_MPL
from utils.logging import ComponentLogger
from utils.helpers import create_color_variations

warnings.filterwarnings('ignore', category=FutureWarning)


class StatisticalAnalyzer(BaseVisualizationAnalyzer):
    """
    Component for statistical analysis of drug scores.
    
    This component:
    1. Loads drug score data from drug2cell analysis
    2. Performs t-tests comparing nephrotoxic vs non-nephrotoxic drugs
    3. Performs Mann-Whitney U tests
    4. Conducts logistic regression analysis
    5. Creates comprehensive visualizations
    6. Generates detailed statistical reports
    """
    
    def __init__(self, config: Dict[str, Any], component_name: str = 'statistical'):
        super().__init__(config, component_name)
        
        # Get input files configuration
        self.input_files = {
            'combined_matrix': 'drug2cell_results/combined_drug_matrix.csv',
            'nephrotoxic_avg': 'drug2cell_results/nephrotoxic_avg_matrix.csv',
            'non_nephrotoxic_avg': 'drug2cell_results/non_nephrotoxic_avg_matrix.csv'
        }
        
        # Update paths based on config
        base_dir = Path(config['output_base_dir'])
        for key, relative_path in self.input_files.items():
            self.input_files[key] = str(base_dir / relative_path)
        
        self.alpha = self.component_config.get('alpha', 0.05)
        self.correction_method = self.component_config.get('correction_method', 'fdr_bh')
        
        self.component_logger = ComponentLogger(component_name, verbose=self.component_config.get('verbose', True))
    
    def validate_inputs(self) -> bool:
        """Validate that required input files exist."""
        missing_files = []
        
        for name, path in self.input_files.items():
            if not Path(path).exists():
                missing_files.append(f"{name}: {path}")
        
        if missing_files:
            self.logger.error("Missing required input files:")
            for file_info in missing_files:
                self.logger.error(f"  - {file_info}")
            return False
        
        return True
    
    def run(self) -> Dict[str, Any]:
        """Run statistical analysis pipeline."""
        self.component_logger.start_component(total_steps=6)
        
        try:
            # Step 1: Load analysis data
            self.component_logger.step_completed("Loading analysis data")
            data = self._load_analysis_data()
            
            # Step 2: Perform statistical tests
            self.component_logger.step_completed("Performing statistical tests")
            ttest_results = self._perform_cell_type_ttests(data['combined_matrix'])
            mannwhitney_results = self._perform_mannwhitney_tests(data['combined_matrix'])
            logistic_result = self._fit_logistic_regression(data['nephrotoxic_avg'], data['non_nephrotoxic_avg'])
            
            # Step 3: Create visualizations
            self.component_logger.step_completed("Creating visualizations")
            self._create_visualizations(data)
            
            # Step 4: Save results
            self.component_logger.step_completed("Saving statistical results")
            saved_files = self._save_results(ttest_results, mannwhitney_results, logistic_result)
            
            # Step 5: Generate summary report
            self.component_logger.step_completed("Generating summary report")
            summary_stats = self._generate_summary_stats(ttest_results, mannwhitney_results)
            
            # Step 6: Create final report
            self.component_logger.step_completed("Creating statistical report")
            self._create_statistical_report(ttest_results, mannwhitney_results, logistic_result, summary_stats)
            
            self.component_logger.finish_component(success=True)
            
            return {
                'ttest_results': ttest_results,
                'mannwhitney_results': mannwhitney_results,
                'logistic_result': logistic_result,
                'summary_stats': summary_stats,
                'saved_files': saved_files,
                'significant_ttests': int(ttest_results['Significant'].sum()),
                'significant_mannwhitney': int(mannwhitney_results['Significant'].sum())
            }
            
        except Exception as e:
            self.component_logger.finish_component(success=False)
            self.logger.error(f"Statistical analysis failed: {e}")
            raise
    
    def _load_analysis_data(self) -> Dict[str, pd.DataFrame]:
        """Load drug score data from drug2cell analysis."""
        self.logger.info("Loading analysis data...")
        
        data = {}
        
        for key, file_path in self.input_files.items():
            self.logger.info(f"Loading {key} from {file_path}")
            
            if key == 'combined_matrix':
                data[key] = pd.read_csv(file_path)
            else:
                data[key] = pd.read_csv(file_path, index_col=0)
            
            self.logger.info(f"Loaded {key}: {data[key].shape}")
        
        return data
    
    def _perform_cell_type_ttests(self, combined_matrix: pd.DataFrame) -> pd.DataFrame:
        """Perform t-tests comparing nephrotoxic vs non-nephrotoxic drugs for each cell type."""
        self.logger.info("Performing t-tests for each cell type...")
        
        cell_types = combined_matrix['cell_type'].unique()
        results = []
        
        for cell_type in cell_types:
            # Subset data for current cell type
            subset = combined_matrix[combined_matrix['cell_type'] == cell_type]
            
            # Get data for each group
            nephrotoxic = subset[subset['group'] == 'nephrotoxic']['log_drug_score']
            non_nephrotoxic = subset[subset['group'] == 'non_nephrotoxic']['log_drug_score']
            
            # Perform t-test (Welch's t-test for unequal variances)
            t_stat, p_val = ttest_ind(nephrotoxic, non_nephrotoxic, equal_var=False)
            
            # Calculate additional statistics
            mean_nephrotoxic = nephrotoxic.mean()
            mean_non_nephrotoxic = non_nephrotoxic.mean()
            log_fold_change = mean_nephrotoxic - mean_non_nephrotoxic
            fold_change = np.exp(log_fold_change)
            
            # Calculate confidence intervals
            n1, n2 = len(nephrotoxic), len(non_nephrotoxic)
            s1, s2 = nephrotoxic.std(), non_nephrotoxic.std()
            se = np.sqrt((s1**2 / n1) + (s2**2 / n2))
            
            df = n1 + n2 - 2
            t_critical = stats.t.ppf(0.975, df)
            margin_of_error = t_critical * se
            
            ci_lower = np.exp(log_fold_change - margin_of_error)
            ci_upper = np.exp(log_fold_change + margin_of_error)
            
            results.append({
                'Cell_Type': cell_type,
                'T_statistic': t_stat,
                'P_value': p_val,
                'Log_Fold_Change': log_fold_change,
                'Fold_Change': fold_change,
                'CI_Lower_95': ci_lower,
                'CI_Upper_95': ci_upper,
                'N_Nephrotoxic': n1,
                'N_Non_nephrotoxic': n2,
                'Mean_Nephrotoxic': mean_nephrotoxic,
                'Mean_Non_nephrotoxic': mean_non_nephrotoxic
            })
        
        results_df = pd.DataFrame(results)
        
        # Apply multiple testing correction
        rejected, corrected_p_values = fdrcorrection(results_df['P_value'], alpha=self.alpha)
        results_df['P_value_corrected'] = corrected_p_values
        results_df['Significant'] = rejected
        
        self.logger.info(f"Completed t-tests for {len(cell_types)} cell types")
        self.logger.info(f"Significant results (FDR < {self.alpha}): {rejected.sum()}")
        
        return results_df
    
    def _perform_mannwhitney_tests(self, combined_matrix: pd.DataFrame) -> pd.DataFrame:
        """Perform Mann-Whitney U tests for each cell type."""
        self.logger.info("Performing Mann-Whitney U tests...")
        
        cell_types = combined_matrix['cell_type'].unique()
        results = []
        
        for cell_type in cell_types:
            subset = combined_matrix[combined_matrix['cell_type'] == cell_type]
            
            nephrotoxic = subset[subset['group'] == 'nephrotoxic']['log_drug_score']
            non_nephrotoxic = subset[subset['group'] == 'non_nephrotoxic']['log_drug_score']
            
            # Perform Mann-Whitney U test
            u_stat, p_val = mannwhitneyu(nephrotoxic, non_nephrotoxic, alternative='two-sided')
            
            results.append({
                'Cell_Type': cell_type,
                'U_statistic': u_stat,
                'P_value': p_val,
                'N_Nephrotoxic': len(nephrotoxic),
                'N_Non_nephrotoxic': len(non_nephrotoxic)
            })
        
        results_df = pd.DataFrame(results)
        
        # Apply multiple testing correction
        rejected, corrected_p_values = fdrcorrection(results_df['P_value'], alpha=self.alpha)
        results_df['P_value_corrected'] = corrected_p_values
        results_df['Significant'] = rejected
        
        self.logger.info(f"Completed Mann-Whitney U tests for {len(cell_types)} cell types")
        
        return results_df
    
    def _fit_logistic_regression(self, nephrotoxic_avg: pd.DataFrame, 
                              non_nephrotoxic_avg: pd.DataFrame) -> BinaryResultsWrapper:
        """Fit logistic regression model."""
        self.logger.info("Fitting logistic regression model...")
        
        # These matrices have cell types as rows and drugs as columns
        # We need to transpose and prepare the data correctly
        
        # Transpose matrices so rows are drugs and columns are cell types
        toxic_data = nephrotoxic_avg.T.copy()  # Now (n_drugs, n_cell_types)
        non_toxic_data = non_nephrotoxic_avg.T.copy()  # Now (n_drugs, n_cell_types)
        
        # Add toxicity labels
        toxic_data['is_toxic'] = 1
        non_toxic_data['is_toxic'] = 0
        
        # Combine data
        combined_data = pd.concat([toxic_data, non_toxic_data])
        
        # Prepare X and y
        X = combined_data.drop('is_toxic', axis=1)
        y = combined_data['is_toxic']
        
        # Clean data: replace inf with NaN, then drop rows with any NaN
        X_clean = X.replace([np.inf, -np.inf], np.nan)
        
        # Get mask for rows without any NaN values
        complete_rows = ~X_clean.isna().any(axis=1)
        X_clean = X_clean[complete_rows]
        y_clean = y[complete_rows]
        
        self.logger.info(f"Original data shape: X={X.shape}, y={y.shape}")
        self.logger.info(f"Cleaned data shape: X={X_clean.shape}, y={y_clean.shape}")
        
        # Check if we have enough data
        if len(X_clean) < 10 or y_clean.nunique() < 2:
            self.logger.warning("Insufficient data for logistic regression after cleaning")
            return None
        
        # Check for constant columns (no variation)
        constant_cols = X_clean.std() == 0
        if constant_cols.any():
            self.logger.info(f"Removing {constant_cols.sum()} constant columns")
            X_clean = X_clean.loc[:, ~constant_cols]
        
        # Add constant term for intercept
        X_clean = sm.add_constant(X_clean)
        
        try:
            # Fit model
            model = Logit(y_clean, X_clean)
            results = model.fit(disp=0, maxiter=1000)  # Suppress convergence warnings
            
            self.logger.info("Logistic regression model fitted successfully")
            return results
            
        except Exception as e:
            self.logger.warning(f"Logistic regression failed: {e}")
            return None
    
    def _create_visualizations(self, data: Dict[str, pd.DataFrame]) -> None:
        """Create comprehensive visualizations."""
        self.logger.info("Creating visualizations...")
        
        combined_matrix = data['combined_matrix']
        nephrotoxic_avg = data['nephrotoxic_avg']
        non_nephrotoxic_avg = data['non_nephrotoxic_avg']
        
        # Create boxplots
        self._create_boxplots(combined_matrix)
        
        # Create publication-quality boxplot
        self._create_publication_boxplot(combined_matrix)
        
        # Create histograms
        self._create_histograms(combined_matrix)
        
        # Create correlation matrix
        self._create_correlation_matrix(nephrotoxic_avg, non_nephrotoxic_avg)
    
    def _create_boxplots(self, combined_matrix: pd.DataFrame) -> None:
        """Create comprehensive boxplots of drug scores."""
        self.logger.info("Creating boxplot visualizations...")
        
        # Basic boxplot
        fig, ax = plt.subplots(figsize=(20, 10))
        sns.boxplot(data=combined_matrix, x='cell_type', y='drug_score', hue='group', palette='viridis', ax=ax)
        ax.tick_params(axis='x', rotation=90)
        ax.set_ylim(0, 1)
        ax.set_title('Drug Scores by Cell Type and Nephrotoxicity')
        plt.tight_layout()
        self.save_figure(fig, 'basic_boxplot')
        self.close_figure(fig)
        
        # Log drug scores boxplot
        fig, ax = plt.subplots(figsize=(20, 10))
        sns.boxplot(data=combined_matrix, x='cell_type', y='log_drug_score', hue='group', palette='viridis', ax=ax)
        ax.tick_params(axis='x', rotation=90)
        ax.set_title('Log Drug Scores by Cell Type and Nephrotoxicity')
        plt.tight_layout()
        self.save_figure(fig, 'log_boxplot')
        self.close_figure(fig)
        
        self.logger.info("Boxplots created")
    
    def _create_publication_boxplot(self, combined_matrix: pd.DataFrame) -> None:
        """Create publication-quality boxplot with cell type grouping."""
        self.logger.info("Creating publication-quality boxplot...")
        
        # Set publication parameters
        plt.rcParams.update(self.plot_config.get('publication_style', {}))
        
        # Count subtypes per main group and create colors
        group_counts = {}
        for cell_type in combined_matrix['cell_type'].unique():
            main_group = CELL_TYPE_MAPPING.get(cell_type, "Other")
            group_counts[main_group] = group_counts.get(main_group, 0) + 1
        
        subtype_colors = {}
        for main_group, count in group_counts.items():
            if main_group in CELL_TYPE_COLORS_MPL:
                variations = create_color_variations(CELL_TYPE_COLORS_MPL[main_group], count)
                idx = 0
                for cell_type in combined_matrix['cell_type'].unique():
                    if CELL_TYPE_MAPPING.get(cell_type, "Other") == main_group:
                        subtype_colors[cell_type] = variations[idx]
                        idx += 1
        
        # Create the plot
        fig, ax = plt.subplots(figsize=(16, 10), dpi=300)
        
        # Sort cell types by main group
        sorted_cell_types = sorted(combined_matrix['cell_type'].unique(), 
                                  key=lambda x: (CELL_TYPE_MAPPING.get(x, "Other"), x))
        
        # Create boxplot data
        boxplot_data = []
        positions = []
        colors = []
        
        current_pos = 0
        for cell_type in sorted_cell_types:
            for group in ['nephrotoxic', 'non_nephrotoxic']:
                mask = (combined_matrix['cell_type'] == cell_type) & (combined_matrix['group'] == group)
                data = combined_matrix[mask]['log_drug_score']
                
                if len(data) > 0:
                    boxplot_data.append(data)
                    positions.append(current_pos + (0 if group == 'nephrotoxic' else 0.4))
                    
                    base_color = subtype_colors.get(cell_type, '#808080')
                    if group == 'nephrotoxic':
                        colors.append(sns.utils.set_hls_values(base_color, l=0.3))  # Darker
                    else:
                        colors.append(sns.utils.set_hls_values(base_color, l=0.7))  # Lighter
            
            current_pos += 1
        
        # Create boxplot
        bp = ax.boxplot(boxplot_data, positions=positions, patch_artist=True, 
                       widths=0.3, showfliers=False)
        
        # Apply colors
        for i, (box, color) in enumerate(zip(bp['boxes'], colors)):
            box.set(facecolor=color, alpha=0.8, edgecolor='black', linewidth=1)
        
        # Customize other elements
        for element in bp['medians']:
            element.set(color='black', linewidth=1.5)
        for element in bp['whiskers'] + bp['caps']:
            element.set(color='black', linewidth=1)
        
        # Set labels and title
        cell_positions = {cell: i for i, cell in enumerate(sorted_cell_types)}
        ax.set_xticks(list(cell_positions.values()))
        ax.set_xticklabels(list(cell_positions.keys()), rotation=45, ha='right')
        ax.set_ylabel('Log Drug Score', fontweight='bold')
        ax.set_title('Drug Scores by Cell Type and Nephrotoxicity', fontweight='bold')
        
        plt.tight_layout()
        self.save_figure(fig, 'publication_boxplot')
        self.close_figure(fig)
        
        self.logger.info("Publication-quality boxplot created")
    
    def _create_histograms(self, combined_matrix: pd.DataFrame) -> None:
        """Create histogram visualizations."""
        self.logger.info("Creating histogram visualizations...")
        
        # Regular drug scores histogram
        fig, ax = plt.subplots(figsize=(12, 6))
        sns.histplot(data=combined_matrix, x='drug_score', hue='group', 
                    kde=True, stat='percent', common_norm=False, palette='viridis', ax=ax)
        ax.set_title('Distribution of Drug Scores')
        plt.tight_layout()
        self.save_figure(fig, 'drug_score_histogram')
        self.close_figure(fig)
        
        # Log drug scores histogram
        fig, ax = plt.subplots(figsize=(12, 6))
        sns.histplot(data=combined_matrix, x='log_drug_score', hue='group', 
                    kde=True, stat='percent', common_norm=False, palette='viridis', ax=ax)
        ax.set_title('Distribution of Log Drug Scores')
        plt.tight_layout()
        self.save_figure(fig, 'log_drug_score_histogram')
        self.close_figure(fig)
        
        self.logger.info("Histograms created")
    
    def _create_correlation_matrix(self, nephrotoxic_avg: pd.DataFrame, 
                                 non_nephrotoxic_avg: pd.DataFrame) -> None:
        """Create correlation matrix visualization."""
        self.logger.info("Creating correlation matrix...")
        
        # Combine matrices for correlation analysis
        combined_for_corr = pd.concat([nephrotoxic_avg, non_nephrotoxic_avg], axis=1)
        combined_for_corr = combined_for_corr.loc[:, ~combined_for_corr.columns.duplicated()]
        
        # Calculate correlation matrix
        corr_matrix = combined_for_corr.corr()
        
        # Regular correlation heatmap
        fig, ax = plt.subplots(figsize=(16, 14))
        sns.heatmap(corr_matrix, cmap='coolwarm', vmin=-1, vmax=1, center=0,
                   annot=False, linewidths=0.5, square=True, ax=ax)
        ax.set_title('Correlation Matrix of Cell Types', fontsize=16)
        ax.tick_params(axis='x', rotation=90, labelsize=8)
        ax.tick_params(axis='y', rotation=0, labelsize=8)
        plt.tight_layout()
        self.save_figure(fig, 'correlation_matrix')
        self.close_figure(fig)
        
        # Clustered correlation heatmap
        g = sns.clustermap(corr_matrix, figsize=(18, 16), cmap='coolwarm',
                          vmin=-1, vmax=1, center=0, method='average',
                          metric='euclidean', linewidths=0.5,
                          dendrogram_ratio=(0.1, 0.1),
                          cbar_kws={"shrink": 0.5, "label": "Correlation Coefficient"})
        
        plt.setp(g.ax_heatmap.get_xticklabels(), rotation=90, fontsize=8)
        plt.setp(g.ax_heatmap.get_yticklabels(), rotation=0, fontsize=8)
        plt.suptitle('Clustered Correlation Matrix of Cell Types', fontsize=16, y=0.98)
        plt.tight_layout()
        
        # Save clustered heatmap
        cluster_path = self.output_dir / 'clustered_correlation_matrix.png'
        g.savefig(cluster_path, dpi=300, bbox_inches='tight')
        self.logger.info(f"Clustered correlation matrix saved to: {cluster_path}")
        
        # Save correlation matrix data
        corr_matrix.to_csv(self.output_dir / 'correlation_matrix.csv')
        
        self.logger.info("Correlation matrix analysis completed")
    
    def _save_results(self, ttest_results: pd.DataFrame, mannwhitney_results: pd.DataFrame,
                     logistic_result) -> Dict[str, Path]:
        """Save analysis results."""
        self.logger.info("Saving statistical results...")
        
        saved_files = {}
        
        # Save test results
        saved_files['ttest'] = self.save_data(ttest_results, 'ttest_results.csv', index=False)
        saved_files['mannwhitney'] = self.save_data(mannwhitney_results, 'mannwhitney_results.csv', index=False)
        
        # Save logistic regression summary if available
        if logistic_result is not None:
            logistic_path = self.output_dir / 'logistic_regression_summary.txt'
            with open(logistic_path, 'w') as f:
                f.write(str(logistic_result.summary()))
            saved_files['logistic'] = logistic_path
        else:
            self.logger.warning("Logistic regression results not available, skipping save")
        
        return saved_files
    
    def _generate_summary_stats(self, ttest_results: pd.DataFrame, 
                              mannwhitney_results: pd.DataFrame) -> Dict[str, Any]:
        """Generate summary statistics."""
        summary_stats = {
            'total_cell_types': len(ttest_results),
            'significant_ttests': int(ttest_results['Significant'].sum()),
            'significant_mannwhitney': int(mannwhitney_results['Significant'].sum()),
            'alpha_level': self.alpha,
            'correction_method': self.correction_method,
            'most_significant_ttest': {
                'cell_type': ttest_results.loc[ttest_results['P_value_corrected'].idxmin(), 'Cell_Type'],
                'p_value': float(ttest_results['P_value_corrected'].min()),
                'fold_change': float(ttest_results.loc[ttest_results['P_value_corrected'].idxmin(), 'Fold_Change'])
            }
        }
        
        # Save summary statistics
        summary_path = self.output_dir / 'statistical_summary.json'
        import json
        with open(summary_path, 'w') as f:
            json.dump(summary_stats, f, indent=2)
        
        return summary_stats
    
    def _create_statistical_report(self, ttest_results: pd.DataFrame, mannwhitney_results: pd.DataFrame,
                                 logistic_result: BinaryResultsWrapper,
                                 summary_stats: Dict[str, Any]) -> None:
        """Create comprehensive statistical report."""
        if not self.config_manager.should_generate_report():
            return
        
        report_path = self.output_dir / "statistical_analysis_report.txt"
        
        with open(report_path, 'w') as f:
            f.write("STATISTICAL ANALYSIS REPORT\n")
            f.write("=" * 50 + "\n\n")
            
            # Summary
            f.write("ANALYSIS SUMMARY:\n")
            f.write(f"  Total cell types analyzed: {summary_stats['total_cell_types']}\n")
            f.write(f"  Significant t-tests: {summary_stats['significant_ttests']}\n")
            f.write(f"  Significant Mann-Whitney tests: {summary_stats['significant_mannwhitney']}\n")
            f.write(f"  Alpha level: {summary_stats['alpha_level']}\n")
            f.write(f"  Correction method: {summary_stats['correction_method']}\n\n")
            
            # Most significant result
            most_sig = summary_stats['most_significant_ttest']
            f.write("MOST SIGNIFICANT RESULT:\n")
            f.write(f"  Cell type: {most_sig['cell_type']}\n")
            f.write(f"  Corrected p-value: {most_sig['p_value']:.2e}\n")
            f.write(f"  Fold change: {most_sig['fold_change']:.3f}\n\n")
            
            # Significant t-test results
            if summary_stats['significant_ttests'] > 0:
                f.write("SIGNIFICANT T-TEST RESULTS:\n")
                significant_ttests = ttest_results[ttest_results['Significant']].sort_values('P_value_corrected')
                for _, row in significant_ttests.iterrows():
                    f.write(f"  {row['Cell_Type']}: p={row['P_value_corrected']:.2e}, FC={row['Fold_Change']:.3f}\n")
                f.write("\n")
            
            # Significant Mann-Whitney results
            if summary_stats['significant_mannwhitney'] > 0:
                f.write("SIGNIFICANT MANN-WHITNEY RESULTS:\n")
                significant_mw = mannwhitney_results[mannwhitney_results['Significant']].sort_values('P_value_corrected')
                for _, row in significant_mw.iterrows():
                    f.write(f"  {row['Cell_Type']}: p={row['P_value_corrected']:.2e}\n")
                f.write("\n")
            
            # Logistic regression summary
            f.write("LOGISTIC REGRESSION:\n")
            if logistic_result is not None:
                f.write(f"  AIC: {logistic_result.aic:.2f}\n")
                f.write(f"  BIC: {logistic_result.bic:.2f}\n")
                f.write(f"  Pseudo R-squared: {logistic_result.prsquared:.3f}\n")
            else:
                f.write("  Logistic regression was not performed due to insufficient or invalid data.\n")
        
        self.logger.info(f"Statistical analysis report saved to: {report_path}")
